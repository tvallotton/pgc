# This file was automatically generated by pgc
# flake8: noqa
# pylint: disable=unused-import
{%- for import in imports %}
import {{import}}
{%- endfor %}
import asyncpg
{%- if query_namespace.name == "" %}
import json
{%- endif %}
import typing
import dataclasses
from {{request.config.codegen.options.package}} import models
{%- for subnamespace in query_namespace.subnamespaces %}
from . import {{subnamespace}}
{%- endfor %}

{%- for method in query_namespace.methods %}

{{ method.query.name | to_screaming_snake_case }} = """
{{ method.query.query  }}
"""
{%- endfor %}
{{"\n"}}
{%- for method in query_namespace.methods %}
{%- if method.output_model != None %}
@dataclasses.dataclass
class {{method.output_model.type.declaration | to_pascal_case }}:
    {%- for field, type in method.output_model.fields | items %}
    {{field}}: {{type.annotation}}
    {%- endfor %}

{% endif %}
{%- for _, input_model in method.input_models | items %}
{%- if method.query.annotations.group_arguments and method.query.annotations.group_arguments.value == "dataclass" %}
@dataclasses.dataclass
class {{ input_model.type.declaration | to_pascal_case }}:
{%- else %}
class {{ input_model.type.declaration | to_pascal_case }}(typing.Protocol):
{%- endif %}
    {%- for field, type in input_model.fields | items %}
    {{field}}: {{type.annotation}}
    {%- endfor %}

{% endfor %}
{%- endfor %}

@dataclasses.dataclass
class {{ query_namespace.name | to_pascal_case }}Queries:
    def __init__(self, connection: asyncpg.Connection):
        self.connection = connection
        {%- for subnamespace in  query_namespace.subnamespaces %}
        self.{{subnamespace}} = {{subnamespace}}.{{subnamespace | to_pascal_case }}Queries(connection)
        {%- endfor %}

    {% for method in query_namespace.methods%}
    {%- if method.query.annotations.not_null_result -%}
    {%- set HANDLE_NONE = 'assert row is not None, "a query marked with @not_null_result has returned null."' %}
    {%- set OR_NONE = '' %}
    {% else %}
    {%- set HANDLE_NONE = 'if row is None: return None' %}
    {%- set OR_NONE = ' | None' %}
    {%- endif %}

    {%- if method.query.command == 'one' %}

    {%- if method.query.output | length == 1 %}
    async def {{method.query.name}}(self
        {%- for argument, type in method.arguments | items -%}
            , {{argument}}: {{type.annotation}}
        {%- endfor -%}
        ) -> {{method.output_type.annotation}}{{OR_NONE}}:
        row = await self.connection.fetchrow(
            {{method.query.name | to_screaming_snake_case }}
            {%- for parameter in method.query.parameters -%}
                , {{parameter.name}}
            {%- endfor %}
        )
        {{HANDLE_NONE}}
        return row[0]
    {%- else %}
    async def {{method.query.name}}(self
        {%- for argument, type in method.arguments | items -%}
            , {{argument}}: {{type.annotation}}
        {%- endfor -%}
        ) -> {{method.output_type.annotation}}{{OR_NONE}}:
        row = await self.connection.fetchrow(
            {{method.query.name | to_screaming_snake_case }}
            {%- for parameter in method.query.parameters -%}
                , {{parameter.name}}
            {%- endfor %}
        )
        {{HANDLE_NONE}}
        return {{method.output_type.annotation}}(**row)
    {%- endif %}
    {%- elif method.query.command == 'many' %}
    {%- if method.query.output | length == 1 %}
    async def {{method.query.name}}(self
        {%- for argument, type in method.arguments | items -%}
            , {{argument}}: {{type.annotation}}
        {%- endfor -%}
        ) -> list[{{method.output_type.annotation}}]:
        rows = await self.connection.fetch(
            {{method.query.name | to_screaming_snake_case }}
            {%- for parameter in method.query.parameters -%}
                , {{parameter.name}}
            {%- endfor %}
        )
        return [row[0] for row in rows]
    {%- else%}
    async def {{method.query.name}}(self
        {%- for argument, type in method.arguments | items -%}
            , {{argument}}: {{type.annotation}}
        {%- endfor -%}
        ) -> list[{{method.output_type.annotation}}]:
        rows = await self.connection.fetch(
            {{method.query.name | to_screaming_snake_case }}
            {%- for parameter in method.query.parameters -%}
                , {{parameter.name}}
            {%- endfor %}
        )
        return [{{method.output_type.annotation}}(**row) for row in rows]
    {%- endif %}
    {%- elif method.query.command == 'val' %}
    async def {{method.query.name}}(self
        {%- for argument, type in method.arguments | items -%}
            , {{argument}}: {{type.annotation}}
        {%- endfor -%}
        ) -> {{method.output_type.annotation}}{{OR_NONE}}:
        row = await self.connection.fetchval(
            {{method.query.name | to_screaming_snake_case }}
            {%- for parameter in method.query.parameters -%}
                , {{parameter.name}}
            {%- endfor %}
        )
        {{HANDLE_NONE}}
        return row


    {%- endif %}

    {% endfor %}



{%- if query_namespace.name == "" %}
async def init_connection(conn: asyncpg.Connection):
    await conn.set_type_codec(
        'jsonb',
        encoder=json.dumps,
        decoder=json.loads,
        schema='pg_catalog'
    )

    await conn.set_type_codec(
        'json',
        encoder=json.dumps,
        decoder=json.loads,
        schema='pg_catalog'
    )

    {%- for _, model_module in model_modules | items %}
    {%- for model in model_module.classes %}

    await conn.set_type_codec(
        {{model.type.pgtype_name | to_c_string }},
        encoder=lambda model: ({% for name, _ in model.fields %}model.{{name}}{% if not loop.last %}, {% endif %}{%endfor%}),
        decoder=lambda row: {{model.type.constructor}}(*row),
        schema={{model.type.pgtype_schema | to_c_string }},
        format="tuple",
    )
    {%- endfor %}
    {% endfor %}
{% endif -%}
