# This file was automatically generated by pgc
# flake8: noqa
# pylint: disable=unused-import
{%- for import in imports %}
import {{import}}
{%- endfor %}
import psycopg
import typing
import dataclasses
from psycopg.rows import dict_row
{%- if query_namespace.name == "" %}
from psycopg.types.composite import CompositeInfo, register_composite
{%- endif %}
from {{request.config.codegen.options.package}} import models
{%- for subnamespace in query_namespace.subnamespaces %}
from . import {{subnamespace}}
{%- endfor %}

{%- for method in query_namespace.methods %}

{{ method.query.name | to_screaming_snake_case }} = """
{{ method.query.query | regex_replace('\\$(\\d+)', '%(p$1)s') }}
"""
{%- endfor %}
{{"\n"}}
{%- for method in query_namespace.methods %}
{%- if method.output_model != None %}
@dataclasses.dataclass
class {{method.output_model.type.declaration | to_pascal_case }}:
    {%- for field, type in method.output_model.fields | items %}
    {{field}}: {{type.annotation}}
    {%- endfor %}

{% endif %}
{%- for _, input_model in method.input_models | items %}
{%- if method.query.annotations.group_arguments and method.query.annotations.group_arguments.value == "dataclass" %}
@dataclasses.dataclass
class {{ input_model.type.declaration | to_pascal_case }}:
    {%- for field, type in input_model.fields | items %}
    {{field}}: {{type.annotation}}
    {%- endfor %}

{%- else %}
class {{ input_model.type.declaration | to_pascal_case }}(typing.Protocol):
    {%- for field, type in input_model.fields | items %}
    @property
    def {{field}}(self) -> {{type.annotation}}: ...
    {%- endfor %}

{%- endif %}
{% endfor %}
{%- endfor %}

@dataclasses.dataclass
class {{ query_namespace.name | to_pascal_case }}Queries:
    def __init__(self, connection: psycopg.Connection):
        self.connection = connection
        {%- for subnamespace in  query_namespace.subnamespaces %}
        self.{{subnamespace}} = {{subnamespace}}.{{subnamespace | to_pascal_case }}Queries(connection)
        {%- endfor %}

    {% for method in query_namespace.methods%}
    {%- if method.query.annotations.not_null_result -%}
    {%- set HANDLE_NONE = 'assert row is not None, "a query marked with @not_null_result has returned null."' %}
    {%- set OR_NONE = '' %}
    {% else %}
    {%- set HANDLE_NONE = 'if row is None: return None' %}
    {%- set OR_NONE = ' | None' %}
    {%- endif %}

    {%- if method.query.command == 'one' %}

    {%- if method.query.output | length == 1 %}
    def {{method.query.name}}(self
        {%- for argument, type in method.arguments | items -%}
            , {{argument}}: {{type.annotation}}
        {%- endfor -%}
        ) -> {{method.output_type.annotation}}{{OR_NONE}}:
        row = self.connection.execute(
            {{method.query.name | to_screaming_snake_case }}, {
            {%- for parameter in method.query.parameters -%}
                "p{{loop.index}}": {{parameter.name}} {%- if not loop.last -%}, {% endif -%}
            {%- endfor %}}
        ).fetchone()
        {{HANDLE_NONE}}
        return row[0]
    {%- else %}
    def {{method.query.name}}(self
        {%- for argument, type in method.arguments | items -%}
            , {{argument}}: {{type.annotation}}
        {%- endfor -%}
        ) -> {{method.output_type.annotation}}{{OR_NONE}}:
        row = self.connection.cursor(row_factory=dict_row).execute(
            {{method.query.name | to_screaming_snake_case }}, {
            {%- for parameter in method.query.parameters -%}
                "p{{loop.index}}": {{parameter.name}} {%- if not loop.last -%}, {% endif -%}
            {%- endfor %}}
        ).fetchone()
        {{HANDLE_NONE}}
        return {{method.output_type.annotation}}(**row)

    {%- endif %}
    {%- elif method.query.command == 'many' %}
    {%- if method.query.output | length == 1 %}
    def {{method.query.name}}(self
        {%- for argument, type in method.arguments | items -%}
            , {{argument}}: {{type.annotation}}
        {%- endfor -%}
        ) -> list[{{method.output_type.annotation}}]:
        rows = self.connection.execute(
            {{method.query.name | to_screaming_snake_case }}, {
            {%- for parameter in method.query.parameters -%}
                "p{{loop.index}}": {{parameter.name}} {%- if not loop.last -%}, {% endif -%}
            {%- endfor %}}
        ).fetchall()
        return [row[0] for row in rows]
    {%- else %}
    def {{method.query.name}}(self
        {%- for argument, type in method.arguments | items -%}
            , {{argument}}: {{type.annotation}}
        {%- endfor -%}
        ) -> list[{{method.output_type.annotation}}]:
        rows = self.connection.cursor(row_factory=dict_row).execute(
            {{method.query.name | to_screaming_snake_case }}, {
            {%- for parameter in method.query.parameters -%}
                "p{{loop.index}}": {{parameter.name}} {%- if not loop.last -%}, {% endif -%}
            {%- endfor %}}
        ).fetchall()
        return [{{method.output_type.annotation}}(**row) for row in rows]

    {%- endif %}
    {%- elif method.query.command == 'val' %}
    def {{method.query.name}}(self
        {%- for argument, type in method.arguments | items -%}
            , {{argument}}: {{type.annotation}}
        {%- endfor -%}
        ) -> {{method.output_type.annotation}}{{OR_NONE}}:
        row = self.connection.execute(
            {{method.query.name | to_screaming_snake_case }}, {
            {%- for parameter in method.query.parameters -%}
                "p{{loop.index}}": {{parameter.name}} {%- if not loop.last -%}, {% endif -%}
            {%- endfor %}}
        ).fetchone()
        {{HANDLE_NONE}}
        return row[0]
    {%- else %}
    def {{method.query.name}}(self
        {%- for argument, type in method.arguments | items -%}
            , {{argument}}: {{type.annotation}}
        {%- endfor -%}
        ):
        return self.connection.execute(
            {{method.query.name | to_screaming_snake_case }}, {
            {%- for parameter in method.query.parameters -%}
                "p{{loop.index}}": {{parameter.name}} {%- if not loop.last -%}, {% endif -%}
            {%- endfor %}}
        )
    {%- endif %}

    {% endfor %}



{%- if query_namespace.name == "" %}
def init_connection(conn: psycopg.Connection):
    {%- for _, model_module in model_modules | items %}
    {%- for model in model_module.classes %}

    register_composite(
        CompositeInfo.fetch(conn, "\"{{model.type.pgtype_schema}}\".\"{{model.type.pgtype_name }}\""), conn, {{model.type.constructor}} # type: ignore
    )
    {%- endfor %}
    {% endfor %}
{% endif -%}
