// This file was automatically generated by pgc
// run `pgc build` to regenerate it
// {%- set options = ir.request.config.codegen.options %}
// {%- if options and options == true %}
import { Buffer } from "node:buffer";
// {%- endif %}
import * as models from "./models/models.ts";
type Step = (cell: string) => any;

function trimOuter(str: string, open: string, close: string) {
  const s = str.trim();
  if (s.startsWith(open) && s.endsWith(close)) return s.slice(1, -1);
  return s;
}

function unquote(s: string): string {
  const t = s.trim();
  if (t.length >= 2 && t.startsWith('"') && t.endsWith('"')) {
    // Remove surrounding quotes and unescape \" and \\ (good enough for most PG cases)
    return t
      .slice(1, -1)
      .replace(/\\(["\\])/g, "$1");
  }
  return t;
}

function splitTopLevel(
  s: string,
  separator: string,
  { respectQuotes = true, parens = true, braces = true }: {
    respectQuotes?: boolean;
    parens?: boolean;
    braces?: boolean;
  } = {},
): string[] {
  const out: string[] = [];
  let buf = "";
  let inQuotes = false;
  let parenDepth = 0;
  let braceDepth = 0;

  const flush = () => {
    out.push(buf);
    buf = "";
  };

  for (let i = 0; i < s.length; i++) {
    const ch = s[i];

    if (respectQuotes && ch === '"' && s[i - 1] !== "\\") {
      inQuotes = !inQuotes;
      buf += ch;
      continue;
    }
    if (!inQuotes) {
      if (parens && (ch === "(" || ch === ")")) {
        if (ch === "(") parenDepth++;
        else parenDepth--;
        buf += ch;
        continue;
      }
      if (braces && (ch === "{" || ch === "}")) {
        if (ch === "{") braceDepth++;
        else braceDepth--;
        buf += ch;
        continue;
      }
      if (parenDepth === 0 && braceDepth === 0 && ch === separator) {
        flush();
        continue;
      }
    }
    buf += ch;
  }
  flush();
  return out.map((t) => t.trim());
}

function parsePgRowToCells(row: string): string[] {
  const inner = trimOuter(row.trim(), "(", ")");
  if (inner === "") return [];
  // Note: allow parentheses/braces in cells; split only at top-level commas
  return splitTopLevel(inner, ",");
}

function parsePgArrayToElements(arr: string): string[] {
  const inner = trimOuter(arr.trim(), "{", "}");
  if (inner === "") return [];
  // In arrays, elements can be quoted (including quoted rows "(...)")
  return splitTopLevel(inner, ",", {
    respectQuotes: true,
    parens: true,
    braces: true,
  });
}

export interface Parser<T> {
  parse(value: string): T;
}

export class NullParser<T> {
  constructor(readonly subparser: Parser<T>) {}

  parse(cell: string): T | null {
    const t = cell.trim();
    if (t == "") return null;
    return this.subparser.parse(cell);
  }
}

export class NumberParser {
  parse(cell: string): number {
    const t = cell.trim();
    const q = unquote(t);
    const v = Number(q);
    if (Number.isNaN(v)) throw new Error(`Invalid number: ${cell}`);
    return v;
  }
}

export class BigIntParser {
  parse(cell: string): bigint {
    if (typeof cell != "string") return cell;
    const t = cell.trim();
    const q = unquote(t);
    const v = BigInt(q);
    return v;
  }
}

export class StringParser {
  parse(cell: string): string {
    const t = cell.trim();
    return unquote(t).replaceAll(/""/g, '"');
  }
}

export class DateParser {
  parse(cell: string): Date {
    const t = unquote(cell.trim());
    const d = new Date(t);
    if (Number.isNaN(d.getTime())) throw new Error(`Invalid date: ${cell}`);
    return d;
  }
}

export class BooleanParser {
  parse(cell: string): boolean {
    const t = unquote(cell.trim());
    if (!["t", "f"].includes(t)) {
      throw new Error(`Invalid boolean: ${cell}. Expected "t" or "f".`);
    }
    return t == "t";
  }
}

export class EnumParser<T> {
  parse(cell: string): T {
    return new StringParser().parse(cell) as T;
  }
}

export class JsonParser {
  parse(cell: string): any {
    const t = unquote(cell);
    return JSON.parse(t);
  }
}

export class BufferParser {
  parse(cell: string): Buffer {
    const t = unquote(cell);
    return Buffer.from(t.replace(/^\\x/, ""), "hex");
  }
}

export class ArrayParser<T> {
  constructor(readonly elementParser: Parser<T>) {}
  parse(array: string | Array<string>): Array<T> {
    let stringArray;

    if (typeof array == "string") {
      const unquoted = unquote(array.trim());
      stringArray = parsePgArrayToElements(unquoted);
    } else {
      stringArray = array;
    }

    return stringArray.map((element) => this.elementParser.parse(element));
  }

  arrayOfThis() {
    return new ArrayParser({ parse: (e) => this.parse(e) });
  }
}

export class RowParser<T extends any[] = [], V = T> {
  private steps: Parser<any>[];
  private mapFun: (_: T) => V;

  constructor(steps: Parser<any>[] = [], map?: (_: T) => V) {
    this.steps = steps;
    this.mapFun = map ?? ((row: T) => row as unknown as V);
  }

  addColumnParser<U>(parser: Parser<U>): RowParser<[...T, U]> {
    return new RowParser<[...T, U]>([...this.steps, parser]);
  }

  parse(input: string): V {
    input = unquote(input);
    const trimmed = input.trim();
    // Accept either full row "(a,b,...)" or a bare CSV (weâ€™ll try row first)
    const cells = trimmed.startsWith("(")
      ? parsePgRowToCells(trimmed)
      : splitTopLevel(trimmed, ",");
    if (cells.length !== this.steps.length) {
      throw new Error(
        `Arity mismatch: expected ${this.steps.length} fields, got ${cells.length} (${
          JSON.stringify(cells)
        })`,
      );
    }
    const out = this.steps.map((parser, i) => parser.parse(cells[i])) as T;
    return this.mapFun(out);
  }

  map<U>(fun: (_: V) => U): RowParser<T, U> {
    const newMap = (row: T) => fun(this.mapFun(row));
    return new RowParser<T, U>(this.steps, newMap);
  }
}

/* parsers for custom types {{"*" + "/"}}
export const parser = {
{%- for module_name, module in ir.model_modules.model_modules | items %}
{%- if module_name in reserved -%}
{%- set module_name = "_" + module_name %}
{%- endif %}
  {{module_name | to_camel_case }}: {
{%- for model in module.models %}
    {{model.name | to_camel_case }}: () => {
      return new RowParser()
        {% for field  in model.fields -%}
        .addColumnParser({{ field.type | type_parser }})
        {% endfor -%}
        .map(([
        {%- for field  in model.fields -%}
          {{field.name | to_camel_case }} {%- if not loop.last %}, {% endif %}
        {%- endfor -%}
        ]) => ({ {{""}}
        {%- for field  in model.fields -%}
        {{field.name | to_camel_case }} {%- if not loop.last %}, {% endif %}
        {%- endfor -%}
        {{""}} }))
    },
    {%- endfor %}
    {%- for enum in module.enums %}
    {{enum.name | to_camel_case }}: () => {
      return new EnumParser<models.{{module_name}}.{{enum.name | to_pascal_case }}>()
    },
    {%- endfor %}
}
{% endfor %}

};

/**/
