# This file was automatically generated by pgc
# flake8: noqa
# pylint: disable=unused-import
import datetime
import typing
import asyncpg
import typing
import dataclasses
from queries import models

UPSERT = """
    insert into author (
        id, name, birthday
    ) values (
        $1, $2, $3
    ) on conflict (id)
    do update set
        id = $1,
        name = $2,
        birthday = $3
    returning author;
"""

GET_BY_ID = """
    select author from author where id = $1;
"""

GET_ALL = """
    select * from author;
"""

GET_ALL2 = """
    select author.* from author;
"""

GET_ALL_WITH_BOOKS = """
    select author, array_agg(book) as books
    from author
    join book on author.id = book.author_id
    group by author.id;
"""

COUNT = """
    select count(*) from author;
"""

SEARCH = """
    select author from author
    order by similarity(name, $1);
"""


class UpsertAuthor(typing.Protocol):
    birthday: datetime.date
    id: str
    name: str


@dataclasses.dataclass
class GetAllRow:
    birthday: datetime.date
    id: str
    name: str


@dataclasses.dataclass
class GetAll2Row:
    birthday: datetime.date
    id: str
    name: str


@dataclasses.dataclass
class GetAllWithBooksRow:
    author: models.public.Author
    books: typing.Any



@dataclasses.dataclass
class AuthorQueries:
    def __init__(self, connection: asyncpg.Connection):
        self.connection = connection

    
    async def upsert(self, author: UpsertAuthor) -> models.public.Author | None:
        row = await self.connection.fetchrow(
            UPSERT, author.id, author.name, author.birthday
        )
        if row is None: return None
        return row[0]

    
    async def get_by_id(self, id: str) -> models.public.Author | None:
        row = await self.connection.fetchrow(
            GET_BY_ID, id
        )
        if row is None: return None
        return row[0]

    
    async def get_all(self) -> list[GetAllRow]:
        rows = await self.connection.fetch(
            GET_ALL
        )
        return [GetAllRow(**row) for row in rows]

    
    async def get_all2(self) -> list[GetAll2Row]:
        rows = await self.connection.fetch(
            GET_ALL2
        )
        return [GetAll2Row(**row) for row in rows]

    
    async def get_all_with_books(self) -> list[GetAllWithBooksRow]:
        rows = await self.connection.fetch(
            GET_ALL_WITH_BOOKS
        )
        return [GetAllWithBooksRow(**row) for row in rows]

    
    async def count(self) -> int | None:
        return await self.connection.fetchval(
            COUNT
        )

    
    async def search(self, term: str) -> list[models.public.Author]:
        rows = await self.connection.fetch(
            SEARCH, term
        )
        return [row[0] for row in rows]

    